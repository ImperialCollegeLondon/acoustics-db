(dp1
S'output'
p2
S"<type 'exceptions.TypeError'> 'long' object is not iterable"
p3
sS'layer'
p4
S'/Users/dorme/Research/SAFE/Web2Py/web2py/applications/Rainforest_Rhythm/controllers/default.py'
p5
sS'code'
p6
S'# -*- coding: utf-8 -*-\n# this file is released under public domain and you can use without limitations\n\nfrom gluon.serializers import json\nimport itertools\nimport math\nfrom pydub import AudioSegment\nimport os\n\n#########################################################################\n## This is a sample controller\n## - index is the default action of any application\n## - user is required for authentication and authorization\n## - download is for downloading files uploaded in the db (does streaming)\n#########################################################################\n\ndef index():\n\t"""\n\texample action using the internationalization operator T and flash\n\trendered by views/default/index.html or views/generic.html\n\n\tif you need a simple wiki simply replace the two lines below with:\n\treturn auth.wiki()\n\t"""\n\tresponse.flash = T("Hello World")\n\treturn dict(message=T(\'Welcome to web2py!\'))\n\ndef player():\n\t\n\t"""\n\tExposes the wavesurfer player, loading a particular audio file \n\tand the calls associated with it\n\t"""\n\t\n\tif request.vars[\'audio_id\']:\n\t\trecord = db.audio(request.vars[\'audio_id\'])\n\telse:\n\t\trecord = db.audio(1)\n\t\n\tif record.previous_part:\n\t\tbackward_link = A(I(_class=\'glyphicon glyphicon-chevron-left\'),\n\t\t\t\t\t\t  _href=URL(\'default\',\'player\', vars={\'audio_id\': record.previous_part}))\n\telse:\n\t\tbackward_link = I()\n\t\n\tif record.next_part:\n\t\tforward_link = A(I(_class=\'glyphicon glyphicon-chevron-right\'),\n\t\t\t\t\t\t  _href=URL(\'default\',\'player\', vars={\'audio_id\':record.next_part}))\n\telse:\n\t\tforward_link = I()\n\t\n\t# get the calls and linked identifications for this audio, using left joins\n\t# to allow calls with no identification\n\taudio = (db.calls.audio_id == record.id)\n\t\n\tdata = db(audio).select(db.calls.id,\n\t\t\t\t\t\t\tdb.calls.start_time,\n\t\t\t\t\t\t\tdb.calls.end_time,\n\t\t\t\t\t\t\tdb.identifications.id,\n\t\t\t\t\t\t\tdb.identifications.current_score,\n\t\t\t\t\t\t\tdb.identifications.n_scores,\n\t\t\t\t\t\t\tdb.taxa.ALL,\n\t\t\t\t\t\t\tleft=[db.identifications.on(db.calls.id == db.identifications.call_id), \n\t\t\t\t\t\t\t\t  db.taxa.on(db.identifications.taxon_id == db.taxa.id)],\n\t\t\t\t\t\t\torderby = db.calls.id)\n\t\n\t# Build the data into a list of call list items with collapsible blocks of \n\t# identification list items \n\tprint data\n\t\n\tif len(data) > 0:\n\t\t# build the data into a dictionary of identifications by call id \n\t\t# NB: This groupby relies on DB query above ordering by the key!\n\t\tdata = {k: list(g) for k, g in itertools.groupby(data, lambda x: x.calls.id)}\n\t\t\n\t\t# now get an order of call ids by start time\n\t\tst_time = {k: v[0].calls.start_time for k, v in data}\n\t\tprint st_time\n\t\t\n\t\t# The structure here is a list-group of the call information, each of which is followed\n\t\t# by its own nested list group of the identifications, which are collapsible. So, users\n\t\t# will always see a list of calls, but the ids are controllable.\n\t\titems = []\n\t\t\n\t\tfor cid in data.keys():\n\t\t\t# call header row, showing play and link to call page. There is always \n\t\t\t# at least one row associated with a call but it may have no ident info\n\t\t\tcinfo = data[cid][0][\'calls\']\n\t\t\tcinfostr = \'{:0.2f} -- {:0.2f}: {:0.2f} seconds\'.format(cinfo.start_time, cinfo.end_time, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcinfo.end_time - cinfo.start_time)\n\t\t\tcall_info = LI(SPAN(_class="glyphicon glyphicon-lg glyphicon-play-circle", \n\t\t\t\t\t\t\t\t_id=\'play_call_\' + str(cinfo.id)),\n\t\t\t\t\t\t\t XML(\'&nbsp\'),\n\t\t\t\t\t\t\t I(cinfostr),\n\t\t\t\t\t\t\t A(SPAN(_class="glyphicon glyphicon-lg glyphicon-info-sign pull-right"), \n\t\t\t\t\t\t\t\t\t_href=URL(\'calls\', vars={\'call_id\': cinfo.id})),\n\t\t\t\t\t\t\t   _class=\'list-group-item call_info\',\n\t\t\t\t\t\t\t   _onmouseover=\'highlight_call(this)\',\n\t\t\t\t\t\t\t   _onmouseout=\'dehighlight_call(this)\',\n\t\t\t\t\t\t\t   _id = \'highlight_\' + str(cinfo.id))\n\t\t\t\n\t\t\titems.append(call_info)\n\t\t\n\t\t\t# Compile identification information for this call if there is any\n\t\t\tidents = data[cid]\n\t\t\tif data[cid][0].identifications.id is None:\n\t\t\t\t  ids_list = [LI("No identification proposed", _class=\'list-group-item small call_id\')]\n\t\t\telse:\n\t\t\t\t# append all the idents onto a list\n\t\t\t\tids_list = []\n\t\t\t\tfor rw in data[cid]:\n\t\t\t\t\tids_list.append(LI(DIV(DIV(rw.taxa.common_name, \' (\',\n\t\t\t\t\t\t\t\t\t\t\t  I(rw.taxa.genus, \' \', rw.taxa.species), \')\',\n\t\t\t\t\t\t\t\t\t\t\t  _class=\'col-sm-6\'),\n\t\t\t\t\t\t\t\t\t\t  _votebar(rw.identifications.current_score,\n\t\t\t\t\t\t\t\t\t\t\t\t   rw.identifications.n_scores,\n\t\t\t\t\t\t\t\t\t\t\t\t   rw.identifications.id,),\n\t\t\t\t\t\t\t\t\t\t  _class=\'row\'),\n\t\t\t\t\t\t\t\t\t  _class=\'list-group-item small call_id\'))\n\t\t\t\n\t\t\t# append the identifications as a collapiblelist group\n\t\t\titems.append(DIV(ids_list, _class=\'list-group collapse\', _id=\'call\' + str(cinfo.id)))\n\t\n\t\tcalls_block = DIV(DIV(DIV("{} calls marked in this recording".format(len(data)),\n\t\t\t\t\t\t\t\t  _class="panel-heading panel-warning"),\n\t\t\t\t\t\t\t  DIV(*items, _class="panel list-group"),\n\t\t\t\t\t\t _class="panel panel-default"),\n\t\t\t\t\t\t _class="container")\n\t\t\n\t\t# Create a JSON object to send to wavesurfer_js region properties\n\t\t# # - start is a reserved word in the web2py framework so can\'t be used directly\n\t\t# # - add an attribute to identify new regions from existing ones.\n\t\tregions = []\n\t\tfor cl in data.values():\n\t\t\tregions.append({\'start\': cl[0].calls.start_time,\n\t\t\t\t\t\t\t\'end\': cl[0].calls.end_time,\n\t\t\t\t\t\t\t\'attributes\':{\'type\': \'fixed\'}})\n\t\t\n\t\tregions = json(regions)\n\telse:\n\t\tcalls_block = DIV(DIV(DIV("No calls yet marked this recording",\n\t\t\t\t\t\t\t\t  _class="panel-heading panel-warning"),\n\t\t\t\t\t\t _class="panel panel-default"),\n\t\t\t\t\t\t _class="container")\n\t\tregions = []\n\t\n\t# pass summary data of identifications to allow javascript \n\t# to load ids for a selected call on the client side\n\treturn dict(record=record, backward_link=backward_link, calls_block=calls_block,\n\t\t\t\tforward_link=forward_link, regions=regions)\n\ndef _seconds_to_time(val):\n\t\n\tm = int(val // 60)\n\ts = int(val % 60)\n\tts = int(val % 1 * 10)\n\t\n\treturn \'{}:{}.{}\'.format(m,s,ts)\n\n@auth.requires_login()\ndef create_call():\n\t\n\taudio_id = request.vars[\'audio_id\']\n\tsource_file = db.audio[audio_id].filename\n\tsource_path = os.path.join(request.folder, \'static\', \'audio\', source_file)\n\tstart = float(request.vars[\'start\'])\n\tend = float(request.vars[\'end\'])\n\t\n\tcall_id = _extract_call_and_add_to_db(source_path, audio_id, start, end, auth.user.id)\n\t\n\treturn call_id \n\n@auth.requires_login()\ndef my_vote():\n\t\n\t"""\n\tInserts a user vote for a particular ID, note that the system keeps\n\ta record of previous votes, rather than just updating them, so the \n\tprevious votes are flagged as replaced. Then calculates and updates \n\tthe weighted mean for the identification\n\t"""\n\t\n\t# get the variables from the call\n\tid_id = request.vars[\'id\']\n\tscore = request.vars[\'score\']\n\t\n\t# get any existing scores by this user for this id \n\t# and update them as replaced\n\tdb((db.scores.user_id == auth.user_id) &\n\t   (db.scores.identification_id == id_id)).update(replaced=True)\n\t\n\t# put in the new values\n\tdb.scores.insert(identification_id=id_id, user_id=auth.user_id,\n\t\t\t\t\t score=score, datetime=datetime.datetime.now())\n\t\n\t# update the identifications with the new score\n\tthese_scores = db((db.scores.identification_id == id_id) &\n\t\t\t\t\t  (db.auth_user.id == db.scores.user_id) &\n\t\t\t\t\t  (db.scores.replaced == False))\n\n\t# get the scores and skills associated with them\n\t# and calculate their weighted meanand the number of scores\n\tid_score  = these_scores.select(((db.auth_user.id_skill * db.scores.score).sum() / \n\t\t\t\t\t\t\t\t\t (db.auth_user.id_skill).sum()).with_alias(\'wt_mean\'),\n\t\t\t\t\t\t\t\t\tdb.scores.score.count().with_alias(\'n_scores\')).first()\n\t\n\tdb(db.identifications.id == id_id).update(current_score=id_score[\'wt_mean\'],\n\t\t\t\t\t\t\t\t\t\t\t  n_scores=id_score[\'n_scores\'])\n\t\n\treturn dict(id_id=id_id, id_score=id_score[\'wt_mean\'])\n\ndef identifications():\n\t\n\t# Create only applies to logged in users\n\tform = SQLFORM.grid((db.identifications.taxon_id == db.taxa.id),\n\t\t\t\t\t\tfields = [db.taxa.common_name, db.taxa.genus, \n\t\t\t\t\t\t\t\t  db.taxa.species, db.taxa.subspecies,\n\t\t\t\t\t\t\t\t  db.identifications.current_score,\n\t\t\t\t\t\t\t\t  db.identifications.n_scores],\n\t\t\t\t\t\tcsv=False,\n\t\t\t\t\t\tcreate=True,\n\t\t\t\t\t\teditable=False,\n\t\t\t\t\t\tdetails=True,\n\t\t\t\t\t\tdeletable=False)\n\t\n\treturn dict(form=form)\n\n\ndef calls():\n\t\n\t# retrieve the call id and audio\n\tif request.vars[\'call_id\']:\n\t\n\t\trecord = db.calls(request.vars[\'call_id\'])\n\t\taudio = db.audio(record.audio_id)\n\t\n\telse:\n\t\t# TODO - where to redirect to\n\t\tredirect(\'index\')\n\t\n\t# get the identifications for this call\n\tidents_query = db((db.identifications.call_id == record.id) &\n\t\t\t\t\t  (db.identifications.taxon_id == db.taxa.id) &\n\t\t\t\t\t  (db.identifications.user_id == db.auth_user.id))\n\t\n\tident_rows = idents_query.select(db.identifications.id,\n\t\t\t\t\t\t\t\t\t db.identifications.created_on,\n\t\t\t\t\t\t\t\t\t db.identifications.current_score,\n\t\t\t\t\t\t\t\t\t db.identifications.n_scores,\n\t\t\t\t\t\t\t\t\t db.taxa.common_name,\n\t\t\t\t\t\t\t\t\t db.taxa.genus,\n\t\t\t\t\t\t\t\t\t db.taxa.species,\n\t\t\t\t\t\t\t\t\t db.taxa.subspecies,\n\t\t\t\t\t\t\t\t\t db.taxa.thumbnail,\n\t\t\t\t\t\t\t\t\t db.auth_user.first_name,\n\t\t\t\t\t\t\t\t\t db.auth_user.last_name)\n\t\n\t# get a list of arguments to set data- options, can\'t set\n\t# arguments with a hyphen in the function\n\titems = []\n\tfor r in ident_rows:\n\t\t# Identification block showing species, proposer and controls\n\t\tident_info = LI(DIV(DIV(IMG(_src=URL(\'static\', \'taxa\', args=r.taxa.thumbnail),\n\t\t\t\t\t\t\t\t\t_width="50", _class="media-object"),\n\t\t\t\t\t\t\t\t_class="media-left"),\n\t\t\t\t\t\t\tDIV(DIV(H5(XML(\'{} (<i>{} {}</i>)\'.format(r.taxa.common_name,\n\t\t\t\t\t\t\t\t\t\t   r.taxa.genus,  r.taxa.species)),\n\t\t\t\t\t\t\t\t\t\t   _class=\'media-heading\'),\n\t\t\t\t\t\t\t\t\t\tTAG.small(\' Proposed by {} {} on {}.\'.format(r.auth_user.first_name, \n\t\t\t\t\t\t\t\t\t\t\t\t  r.auth_user.last_name, r.identifications.created_on)),\n\t\t\t\t\t\t\t\t\t_class=\'col-sm-6\'),\n\t\t\t\t\t\t\t\tDIV(_votebar(r.identifications.current_score, \n\t\t\t\t\t\t\t\t\t\t\t r.identifications.n_scores,\n\t\t\t\t\t\t\t\t\t\t\t r.identifications.id),\n\t\t\t\t\t\t\t\t\t_your_vote(1, r.identifications.id),\n\t\t\t\t\t\t\t\t\t_class=\'col-sm-6\'),\n\t\t\t\t\t\t\t\t_class=\'media-body\'),\n\t\t\t\t\t\t\t_class="media"),\n\t\t\t\t\t\t_class=\'list-group-item call_info\')\n\t\t\n\t\titems.append(DIV(ident_info, _id=\'ident\' + str(r.identifications.id)))\n\t\n\n\t\n\tlist_group = DIV(*items, _class="panel list-group")\n\t\n\treturn dict(record=record, audio=audio, list_group=list_group) #, modal_str=modal_str)\n\ndef recordings():\n\t\n\tlinks = [dict(header = \'\', \n\t\t\t\t  body = lambda row: A(SPAN(\'\',_class="glyphicon glyphicon-play"),\n\t\t\t\t\t\t\t\t\t   XML(\'&nbsp;\'),\n\t\t\t\t\t\t\t\t\t   SPAN(\'Play\', _class="buttontext button"),\n\t\t\t\t\t\t\t\t\t   _class="btn btn-default", \n\t\t\t\t\t\t\t\t\t   _href=URL("player", vars={\'audio_id\':row.id}),\n\t\t\t\t\t\t\t\t\t   _style=\'padding: 3px 5px 3px 5px;\'))]\t \n\t\n\tform = SQLFORM.grid(db.audio,\n\t\t\t\t\t\tfields=[db.audio.filename, db.audio.start_datetime, db.audio.length_seconds],\n\t\t\t\t\t\tcsv=False,\n\t\t\t\t\t\tcreate=False,\n\t\t\t\t\t\teditable=False,\n\t\t\t\t\t\tdetails=False,\n\t\t\t\t\t\tdeletable=False,\n\t\t\t\t\t\tlinks=links)\n\t\n\treturn dict(form=form)\n\ndef taxa():\n\t\n\t# Create only applies to logged in users\n\tform = SQLFORM.grid(db.taxa,\n\t\t\t\t\t\tfields = [db.taxa.common_name, db.taxa.genus, \n\t\t\t\t\t\t\t\t  db.taxa.species, db.taxa.subspecies],\n\t\t\t\t\t\tcsv=False,\n\t\t\t\t\t\tcreate=True,\n\t\t\t\t\t\teditable=False,\n\t\t\t\t\t\tdetails=True,\n\t\t\t\t\t\tdeletable=False)\n\t\n\treturn dict(form=form)\n\ndef taxon():\n\t\n\tif request.vars[\'taxon_id\']:\n\t\trecord = db.taxa(request.vars[\'taxon_id\'])\n\telse:\n\t\trecord = db.taxa(1)\n\t\n\t\n\tform = SQLFORM(db.taxa, record=record, readonly=True)\n\t\n\treturn dict(form=form)\n\n\ndef user():\n\t"""\n\texposes:\n\thttp://..../[app]/default/user/login\n\thttp://..../[app]/default/user/logout\n\thttp://..../[app]/default/user/register\n\thttp://..../[app]/default/user/profile\n\thttp://..../[app]/default/user/retrieve_password\n\thttp://..../[app]/default/user/change_password\n\thttp://..../[app]/default/user/bulk_register\n\tuse @auth.requires_login()\n\t\t@auth.requires_membership(\'group name\')\n\t\t@auth.requires_permission(\'read\',\'table name\',record_id)\n\tto decorate functions that need access control\n\talso notice there is http://..../[app]/appadmin/manage/auth to allow administrator to manage users\n\t"""\n\treturn dict(form=auth())\n\n\n@cache.action()\ndef download():\n\t"""\n\tallows downloading of uploaded files\n\thttp://..../[app]/default/download/[filename]\n\t"""\n\treturn response.download(request, db)\n\n\ndef call():\n\t"""\n\texposes services. for example:\n\thttp://..../[app]/default/call/jsonrpc\n\tdecorate with @services.jsonrpc the functions to expose\n\tsupports xml, json, xmlrpc, jsonrpc, amfrpc, rss, csv\n\t"""\n\treturn service()\n\n\n\nresponse._vars=response._caller(player)\n'
p7
sS'snapshot'
p8
(dp9
sS'traceback'
p10
S'Traceback (most recent call last):\n  File "/Users/dorme/Research/SAFE/Web2Py/web2py/gluon/restricted.py", line 227, in restricted\n    exec ccode in environment\n  File "/Users/dorme/Research/SAFE/Web2Py/web2py/applications/Rainforest_Rhythm/controllers/default.py", line 376, in <module>\n  File "/Users/dorme/Research/SAFE/Web2Py/web2py/gluon/globals.py", line 412, in <lambda>\n    self._caller = lambda f: f()\n  File "/Users/dorme/Research/SAFE/Web2Py/web2py/applications/Rainforest_Rhythm/controllers/default.py", line 77, in player\n    st_time = {k: v[0].calls.start_time for k, v in data}\n  File "/Users/dorme/Research/SAFE/Web2Py/web2py/applications/Rainforest_Rhythm/controllers/default.py", line 77, in <dictcomp>\n    st_time = {k: v[0].calls.start_time for k, v in data}\nTypeError: \'long\' object is not iterable\n'
p11
s.